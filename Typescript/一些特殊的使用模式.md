```typescript
type PrimaryType = string | number | undefined | null | boolean;
type Rest<V, T> = V extends T ? never : V;
type NotEmpty<T> = T extends null | undefined | infer U ? U : never;
type a = Rest<PrimaryType, undefined | null>;
type B = NotEmpty<PrimaryType>;
```

#### å°†ä¸€ä¸ªä¸å®šé•¿åº¦çš„æ•°ç»„ä½œä¸ºTupleå¤„ç†

ä¹‹å‰æœ‰ä¸€ä¸ªéœ€æ±‚ï¼Œå‡½æ•°æ¥æ”¶ä¸€ä¸ªä¸å®šé•¿åº¦æ•°ç»„ï¼Œè¿”å›ä¸€ä¸ªå‡½æ•°ï¼Œè¿™ä¸ªå‡½æ•°æ¥å—ä¸€ä¸ªå¯¹è±¡ï¼Œå¯¹è±¡çš„é”®åå¯¹åº”æ•°ç»„ä¸­çš„æ¯ä¸ªå…ƒç´ ã€‚

ä¸€èˆ¬æ¥è¯´ï¼Œè¿™ä¸ªå‡½æ•°çš„TSå®ç°éœ€è¦ç”¨åˆ°å‡½æ•°é‡è½½ï¼Œä½†å¦‚æœä½¿ç”¨é‡è½½å»å®ç°ï¼Œå¯èƒ½è¦å†™éå¸¸éå¸¸å¤šä¸ªï¼Œäºæ˜¯å½“æ—¶çš„æ‘¸ç´¢å‡ºä¸€ä¸ªå®ç°å¦‚ä¸‹ï¼š

```typescript
type ArrayToUnionType<T> = T extends [infer A, ...infer L] ? A | ArrayToUnionType<L> : never;

function returnCreatePath<ParamsArr extends [T] | string[], T extends string> (params: ParamsArr) {
  const createPath = (search:{[key in ArrayToUnionType<ParamsArr>]: string })=>{};
  return createPath;
}

// ä¸Šé¢çš„æ•ˆæœç­‰åŒäº ğŸ‘‡ çš„å‡½æ•°é‡è½½
function <Arg extends string, Params extends [Arg]> () {}
function <Arg extends string, Arg2 extends string, Params extends [Arg] | [Arg, Arg2]> () {}
function <Arg extends string, Arg2 extends string, Arg3 extends string, Params extends [Arg] | [Arg, Arg2]|[Arg, Arg2, Arg3]> () {}
// æ— é™é‡è½½ä¸‹å»
```

è™½ç„¶å®ç°äº†éœ€æ±‚ï¼Œä½†æ˜¯å¹¶æ²¡æœ‰å¾ˆæ¸…æ¥šèŒƒå‹éƒ¨åˆ†ä¸ºä»€ä¹ˆè¦è¿™æ ·å†™ï¼š`<ParamsArr extends [T] | string[], T extends string>`ã€‚é€šè¿‡æŸ¥æ‰¾å®˜ç½‘ï¼Œå¯ä»¥æ‰¾åˆ°ä¸»è¦åŸå› åœ¨[Variadic Tuple Types](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-0.html#variadic-tuple-types)ï¼Œä¸€ä¸ªTS4.0æ–°å¢çš„åŠŸèƒ½ï¼Œæˆ‘å½“æ—¶ç”¨çš„TSç‰ˆæœ¬>4.0ã€‚

> The first change is that spreads in tuple type syntax can now be generic. This means that we can represent higher-order operations on tuples and arrays even when we donâ€™t know the actual types weâ€™re operating over. When generic spreads are instantiated (or, replaced with a real type) in these tuple types, they can produce other sets of array and tuple types.
>
> The second change is that rest elements can occur anywhere in a tuple - not just at the end!

æ‰€ä»¥æ ‡å‡†å†™æ³•åº”è¯¥æ˜¯ï¼š

```typescript
type ArrayToUnionType<T> = T extends [infer A, ...infer L] ? A | ArrayToUnionType<L> : never;

function returnCreatePath<ParamsArr extends string[]> (params: [...ParamsArr]) {
  const createPath = (search:{[key in ArrayToUnionType<ParamsArr>]: string })=>{};
  return createPath;
}
```

ä½†æ˜¯ `{[key in ArrayToUnionType<ParamsArr>]: string }`ä¼šæŠ¥é”™ï¼Œåº”è¯¥è·ŸèŒƒå‹æœ‰å…³ï¼Œå¾…ç»§ç»­ç ”ç©¶ã€‚ã€‚ã€‚

```typescript
type ArrayToUnionType<T> = T extends [infer A, ...infer L] ? A | ArrayToUnionType<L> : never;
//                                                   åŠ ä¸ªè¿™ä¸ªå°±ä¸ä¼šæŠ¥é”™
function returnCreatePath<ParamsArr extends string[] | [string]> (params: [...ParamsArr]) {
  const createPath = (search:{[key in ArrayToUnionType<ParamsArr>]: string })=>{};
  return createPath;
}
```

