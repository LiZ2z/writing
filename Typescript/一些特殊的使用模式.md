```typescript
type PrimaryType = string | number | undefined | null | boolean;
type Rest<V, T> = V extends T ? never : V;
type NotEmpty<T> = T extends null | undefined | infer U ? U : never;
type a = Rest<PrimaryType, undefined | null>;
type B = NotEmpty<PrimaryType>;
```

#### 将一个不定长度的数组作为Tuple处理

一个需求，函数接收一个不定长度数组，返回一个对象，对象的键名对应数组中的每个元素。

```typescript
type ArrayToUnionType<T> = T extends [infer A, ...infer L] ? A | ArrayToUnionType<L> : never;

function <ParamsArr extends [T] | string[], T extends string> () {
  return (params:{[key in ArrayToUnionType<ParamsArr>]: string })=>{}
}

// 上面的效果等同于 👇 的函数重载
function <Arg extends string, Params extends [Arg]> () {}
function <Arg extends string, Arg2 extends string, Params extends [Arg] | [Arg, Arg2]> () {}
function <Arg extends string, Arg2 extends string, Arg3 extends string, Params extends [Arg] | [Arg, Arg2]|[Arg, Arg2, Arg3]> () {}
// 无限重载下去
```

可以找到部分解释在[这里](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-0.html#variadic-tuple-types)

